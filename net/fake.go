// Sean at shanghai
// 2020.07

package net

import (
	"log"
	"net/http"
	"strconv"
	"strings"
)

const Header = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Noval List</title>
    <!-- Bootstrap11111111111 core CSS -->
    <link href="https://cdn.bootcss.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
  </head>
  <body>
    <div class="container">
      <div class="blog-header">
        <h1 class="blog-title">This HTML file is generated by golang</h1>
        <p class="lead blog-description">Please see real txt file at /realentxt </p>
      </div>
      <div class="row">
        <div class="col-sm-8 blog-main">
          <div class="blog-post">
              <h2 class="blog-post-title">小说集锦 by dilfish</h2>
              <p class="blog-post-meta">i at <a>dilfish.dev</a></p>
<hr> <p>
`

const Tail = `</p>
  </div><!-- /.blog    -post -->
        </div><!-- /.blog-main -->
      </div><!-- /.row -->

    </div><!-- /.container -->
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
  </body>
</html>

`

type FakeHandler struct {
	FileHandler http.Handler
}

type FakeResponse struct {
	orig http.ResponseWriter
	head bool
}

func (f *FakeResponse) Header() http.Header {
	return f.orig.Header()
}

func (f *FakeResponse) modifyLen() {
	h := f.orig.Header()
	cl := h["Content-Length"]
	if len(cl) < 1 {
		return
	}
	cln, err := strconv.ParseUint(cl[0], 10, 32)
	if err != nil {
		log.Println("parse uint cl error", cl, err)
		return
	}
	// extra <p> and </p>
	cln = cln + uint64(len(Header)+len(Tail))
	h.Set("Content-Length", strconv.FormatUint(cln, 10))
	h.Set("Content-Type", "text/html; charset=utf-8")
}

func (f *FakeResponse) WriteHeader(statusCode int) {
	f.modifyLen()
	f.orig.WriteHeader(statusCode)
}

func (f *FakeResponse) Write(b []byte) (int, error) {
	if !f.head {
		f.orig.Write([]byte(Header))
		f.head = true
	}
	return f.orig.Write(b)
}

func (h *FakeHandler) IsUsingFakeResponse(uri string) bool {
	if strings.HasSuffix(uri, ".go") {
		return true
	}
	if strings.HasSuffix(uri, ".txt") {
		return true
	}
	return false
}

func PrintMapValue(msg string, str []string) string {
	if len(str) < 1 {
		return ""
	}
	v := str[0]
	log.Println(msg, v)
	return v
}

func (h *FakeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	log.Println("request is", r.Method, r.RequestURI)
	cip := PrintMapValue("Cf-Connecting-Ip", r.Header["Cf-Connecting-Ip"])
	PrintMapValue("Cf-Request-Id", r.Header["Cf-Request-Id"])
	PrintMapValue("User-Agent", r.Header["User-Agent"])
	forip := PrintMapValue("X-Forwarded-For", r.Header["X-Forwarded-For"])
	realip := PrintMapValue("X-Real-Ip", r.Header["X-Real-Ip"])
	hdr := w.Header()
	hdr.Set("x-server", "iPhone 6s")
	hdr.Set("x-cf-conn-ip", cip)
	hdr.Set("x-forward-ip", forip)
	hdr.Set("x-real-ip", realip)
	if strings.HasPrefix(r.RequestURI, "/realentxt") {
		r.RequestURI = strings.Replace(r.RequestURI, "/realentxt/", "/entxt/", -1)
		if r.URL != nil {
			r.URL.Path = strings.Replace(r.URL.Path, "/realentxt/", "/entxt/", -1)
		}
		log.Println(r.RequestURI)
		h.FileHandler.ServeHTTP(w, r)
		return
	}
	if h.IsUsingFakeResponse(r.RequestURI) {
		var f FakeResponse
		f.orig = w
		h.FileHandler.ServeHTTP(&f, r)
		f.orig.Write([]byte(Tail))
		return
	}
	h.FileHandler.ServeHTTP(w, r)
}
